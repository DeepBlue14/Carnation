// Generated by CoffeeScript 1.9.3

/* 
 * File: graphics.js
 * Author: James Kuczynski
 * File Description: This file implements the dynamic background using
 * 					 Three.js, a WebGL library for creating 3D elements.
 * 
 * Last Modified: 11/21/2018
 */


/**
 * Initializes the 3D graphcs for the background objects and adds them
 * to the web page.
 */

(function() {
  var animate, camera, container, geometry, h, i, init, materials, onWindowResize, parameters, pointLight, render, renderer, scene, size, sprite, windowHalfX, windowHalfY;

  init = function() {
    var ambient, camera, container, geometry, i, mesh, parameters, particles, pointLight, r, renderer, scene, size, sphere, sprite, sprite1, sprite2, sprite3, sprite4, sprite5, textureCube, textureLoader, urls, vertex;
    container = document.createElement('div');
    document.body.appendChild(container);
    camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 100000);
    camera.position.z = 2000;
    r = 'res/';
    urls = [r + 'posx.jpg', r + 'negx.jpg', r + 'posy.jpg', r + 'negy.jpg', r + 'posz.jpg', r + 'negz.jpg'];
    textureCube = (new THREE.CubeTextureLoader).load(urls);
    textureCube.mapping = THREE.CubeRefractionMapping;
    scene = new THREE.Scene;
    scene.background = textureCube;
    scene.fog = new THREE.FogExp2(0x000000, 0.0008);
    ambient = new THREE.AmbientLight(0xffffff);
    scene.add(ambient);
    pointLight = new THREE.PointLight(0xffffff, 2);
    scene.add(pointLight);
    sphere = new THREE.SphereGeometry(100, 16, 8);
    mesh = new THREE.Mesh(sphere, new THREE.MeshBasicMaterial({
      color: 0xffffff
    }));
    mesh.scale.set(0.05, 0.05, 0.05);
    pointLight.add(mesh);
    renderer = new THREE.WebGLRenderer;
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    container.appendChild(renderer.domElement);
    geometry = new THREE.Geometry;
    textureLoader = new THREE.TextureLoader;
    sprite1 = textureLoader.load(r + 'snowflake.png');
    sprite2 = textureLoader.load(r + 'snowflake.png');
    sprite3 = textureLoader.load(r + 'snowflake.png');
    sprite4 = textureLoader.load(r + 'snowflake2.png');
    sprite5 = textureLoader.load(r + 'snowflake2.png');
    i = 0;
    while (i < 100000) {
      vertex = new THREE.Vector3;
      vertex.x = Math.random() * 10000 - 1000;
      vertex.y = Math.random() * 10000 - 1000;
      vertex.z = Math.random() * 10000 - 1000;
      geometry.vertices.push(vertex);
      i++;
    }
    parameters = [[[1.0, 0.2, 0.5], sprite2, 20], [[0.95, 0.1, 0.5], sprite3, 15], [[0.90, 0.05, 0.5], sprite1, 10], [[0.85, 0, 0.5], sprite5, 8], [[0.80, 0, 0.5], sprite4, 5]];
    i = 0;
    while (i < parameters.length) {
      sprite = parameters[i][1];
      size = parameters[i][2];
      materials[i] = new THREE.PointsMaterial({
        size: size,
        map: sprite,
        blending: THREE.AdditiveBlending,
        depthTest: false,
        transparent: true
      });
      particles = new THREE.Points(geometry, materials[i]);
      particles.rotation.x = Math.random() * 6;
      particles.rotation.y = Math.random() * 6;
      particles.rotation.z = Math.random() * 6;
      scene.add(particles);
      i++;
    }
    window.addEventListener('resize', onWindowResize, false);
  };


  /**
   * Resizes the 3D elements when the page is resized.
   *
   */

  onWindowResize = function() {
    var windowHalfX, windowHalfY;
    windowHalfX = window.innerWidth / 2;
    windowHalfY = window.innerHeight / 2;
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  };


  /**
   * Function the three.js API calls to update the UI.
   */

  animate = function() {
    requestAnimationFrame(animate);
    render();
  };


  /**
   * Re-renders the 3D elements.  Also contains
   */

  render = function() {
    var i, object, time;
    time = Date.now() * 0.00005;
    i = 0;
    while (i < scene.children.length) {
      object = scene.children[i];
      if (object instanceof THREE.Points) {
        object.rotation.x = time * (i < 4 ? i + 1 : -(i + 1));
        object.rotation.y = time * (i < 4 ? i + 1 : -(i + 1));
        object.rotation.z = time * (i < 4 ? i + 1 : -(i + 1));
      }
      i++;
    }
    camera.rotation.y += 0.001;
    renderer.render(scene, camera);
  };

  'use strict';

  if (!Detector.webgl) {
    Detector.addGetWebGLMessage();
  }

  container = void 0;

  camera = void 0;

  scene = void 0;

  renderer = void 0;

  geometry = void 0;

  pointLight = void 0;

  windowHalfX = window.innerWidth / 2;

  windowHalfY = window.innerHeight / 2;

  materials = [];

  parameters = void 0;

  i = void 0;

  h = void 0;

  sprite = void 0;

  size = void 0;

  init();

  animate();

}).call(this);

//# sourceMappingURL=graphics-copy.js.map
