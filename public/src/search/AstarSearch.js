// Generated by CoffeeScript 1.9.3
(function() {
  var AstarSearch, Image, Node2i, SearchAbc, SearchNode,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Node2i = require('./Node2i.coffee');

  SearchNode = require('./SearchNode.coffee');

  SearchAbc = require('./SearchAbc.coffee');

  Image = require('./../sensor_msgs/Image.coffee');

  AstarSearch = (function(superClass) {
    extend(AstarSearch, superClass);

    AstarSearch.costmap;

    AstarSearch.closedmap;

    AstarSearch.openmap;

    AstarSearch.scanvas;

    AstarSearch.smask;

    AstarSearch.DOUBLE_MAX;

    AstarSearch.DOUBLE_MIN;

    AstarSearch.useDebugMode;

    AstarSearch.isFirstTime;

    AstarSearch.lastNode;


    /*
     * Initialize the search
     * @param costmap: The costmap for a given raster
     * @param startXy: The start position (no orientation)
     * @param goalXy: The goal position (no orientation)
     */

    function AstarSearch(costmap, startXy1, goalXy1) {
      this.costmap = costmap;
      this.startXy = startXy1;
      this.goalXy = goalXy1;
      AstarSearch.__super__.constructor.call(this, 10.0, 10.0);
    }

    AstarSearch.prototype.run = function(startXy, goalXy) {
      var fs, goal, idx, obj, openLst, ref, start, val;
      if (startXy.x < 0 || startXy.x >= this.costmap.cols || startXy.y < 0 || startXy.y > this.costmap.rows || goalXy.x < 0 || goalXy.x >= this.costmap.rows || goalXy.y < 0 || goalXy.y > this.costmap.cols) {
        console.log("ERROR: start or goal pos exeeds image bounds -- bye!");
        console.log("map (x, y): (" + this.costmap.rows + ", " + this.costmap.cols + ")");
        console.log("(" + startXy.x + ", " + startXy.y + ") ==> (" + goalXy.x + ", " + goalXy.y + ")");
        return;
      }
      openLst = [];
      start = new SearchNode.SearchNode(startXy.x, startXy.y, 0, 0, null);
      goal = new SearchNode.SearchNode(goalXy.x, goalXy.y, 0, 0, null);
      openLst.push(start);
      this.closedmap = new Image.Image('../res/arc/UMassLowell/North/OlsenHall/olsen_hall_floor3.png');
      this.closedmap.zeros();
      this.openmap = new Image.Image('../res/arc/UMassLowell/North/OlsenHall/olsen_hall_floor3.png');
      this.openmap.zeros();
      this.openmap.setAt2(start.x, start.y, start.f + 1.0, start.f + 1.0, start.f + 1.0);

      /*
      counter = 0
      while(openLst.length > 0)
          console.log "loop..."
          q = new SearchNode.SearchNode()
          q = openLst.pop() #get last and remove
          @openmap.setAt2(q.x, q.y, 0.0, 0.0, 0.0)
          
          console.log "(" + q.x + ", " + q.y + "): q.pixSum: " + q.pixSum + " q.pix: " + q.pix
          
          successorLst = this.getSuccessors(q)
          console.log "looping \"for\" " + successorLst.length + " successors"
          for i in [0...successorLst.length]
              successorLst[i].g = q.g + this.calcLinearDistance(successorLst[i], q)
              successorLst[i].h = this.calcManhattenDistance(successorLst[i], goal)
              successorLst[i].f = successorLst[i].g + successorLst[i].h + successorLst[i].pixSum #FIXME: or ...->pix ???
      
               * TODO: Allow off-by-one check because of the diagonal and dual-linear-step method
              if successorLst[i].x is goal.x && successorLst[i].y is goal.y
                  lastNode = successorLst[i].clone()
                  if @useDebugMode
                      console.log('Found goal -- Bye!')
                      console.log(toString() )
                      #displayPath(successorLst[i])
      
                  this.updateMask(lastNode)
      
                  openLst = []
                  #deallocateAll()
                  return
              
              
              foundMatch = false
              if @openmap.getAt(successorLst[i].x, successorLst[i].y).r <= successorLst[i].f && @openmap.getAt(successorLst[i].x, successorLst[i].y).r > 0.0
                  foundMatch = true
              if foundMatch == false
                  if @closedmap.getAt(successorLst[i].x, successorLst[i].y).r <= successorLst[i].f && @closedmap.getAt(successorLst[i].x, successorLst[i].y).r > 0
                      foundMatch = true
          
              if foundMatch != true
                  openLst.push(successorLst[i])
                  if successorLst[i].f > 0.0
                      @openmap.setAt2(successorLst[i].x, successorLst[i].y, successorLst[i].f, successorLst[i].f, successorLst[i].f)
                  else
                      @openmap.setAt2(successorLst[i].x, successorLst[i].y, 1, 1, 1)
              #else
               *    console.log "Match found; we are done!?!"
      
          if q.f > 0.0
              @closedmap.setAt2(q.x, q.y, q.f, q.f, q.f)
          else
              @closedmap.setAt2(q.x, q.y, 1.0, 1.0, 1.0)
      
          successorLst = []    
      #end of while(...)
       */
      fs = require('fs');
      obj = JSON.parse(fs.readFileSync('./path.json', 'utf8'));
      ref = obj.path;
      for (idx in ref) {
        val = ref[idx];
        console.log(val.y + ", " + val.x);
        this.costmap.setAt2(val.y, val.x, 100, 0, 100);
      }
      return this.costmap.saveAsync('my_path.png');
    };

    AstarSearch.prototype.getMask = function() {
      return this.smask;
    };

    AstarSearch.prototype.displayImage = function(windowName, image, useWaitKey, waitKey, x, y) {};

    AstarSearch.prototype.toString = function() {
      var str;
      str = '--------AstarSearch--------';
      str.append('\nnodes:=' + lastNode.childCount);
      str.append('\npixel cost:=' + lastNode.pixSum);
      str.append('\nnorth:=' + lastNode.twist.nCout);
      str.append('\nsouth:=' + lastNode.twist.sCount);
      str.append('\neast:=' + lastNode.twist.eCount);
      str.append('\nwest:=' + lastNode.twist.wCount);
      str.append('\nnorth-east:=' + lastNode.twist.neCount);
      str.append('\nnorth-west:=' + lastNode.twist.nwCount);
      str.append('\nsouth-east:=' + lastNode.twist.seCount);
      str.append('\nsouth-west:=' + lastNode.twist.swCount);
      str.append('\n---------------------------\\n');
      return str;
    };

    AstarSearch.prototype.getSuccessors = function(node) {
      var successors;
      successors = [];
      successors.push(this.generateNode(node.x + 1, node.y - 1, 3, 3, node));
      if (node.x > 5 && node.x < (this.costmap.cols - 5) && node.y > 5 && node.y < (this.costmap.rows - 5)) {
        successors.push(this.generateNode(node.x + 1, node.y - 1, 3, 3, node));
        successors.push(this.generateNode(node.x - 1, node.y + 1, 4, 4, node));
        successors.push(this.generateNode(node.x + 1, node.y + 1, 2, 2, node));
        successors.push(this.generateNode(node.x - 1, node.y - 1, 1, 1, node));
      }
      return successors;
    };

    AstarSearch.prototype.generateNode = function(x, y, direction, channel, parent) {
      var node;
      node = new SearchNode.SearchNode(x, y, direction, channel, parent);
      node.pix = this.costmap.getAt(x, y).r / 10;
      if (parent === null) {
        node.pixSum = node.pix;
      } else if (parent.pixSum + node.pix < 256 - 1) {
        node.pixSum = parent.pixSum + node.pix;
      } else {
        node.pixSum = 256 - 10;
      }
      return node;
    };

    AstarSearch.prototype.display = function(openLst, closedLst, start, goal) {};

    AstarSearch.prototype.display = function(lastNode, openLst, closedLst, start, goal) {};

    AstarSearch.prototype.updateMask = function(lastNode) {};

    return AstarSearch;

  })(SearchAbc.SearchAbc);

  if (typeof module !== "undefined" && module.exports) {
    exports.AstarSearch = AstarSearch;
  } else {
    window.AstarSearch = AstarSearch;
  }

}).call(this);

//# sourceMappingURL=AstarSearch.js.map
