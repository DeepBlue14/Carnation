// Generated by CoffeeScript 1.9.3
(function() {
  var AstarSearch, Image, Node2i, SearchAbc, SearchNode,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Node2i = require('./Node2i.coffee');

  SearchNode = require('./SearchNode.coffee');

  SearchAbc = require('./SearchAbc.coffee');

  Image = require('./../sensor_msgs/Image.coffee');

  AstarSearch = (function(superClass) {
    extend(AstarSearch, superClass);

    AstarSearch.costmap;

    AstarSearch.closedmap;

    AstarSearch.openmap;

    AstarSearch.scanvas;

    AstarSearch.smask;

    AstarSearch.DOUBLE_MAX;

    AstarSearch.DOUBLE_MIN;

    AstarSearch.useDebugMode;

    AstarSearch.isFirstTime;

    AstarSearch.lastNode;


    /*
     * Initialize the search
     * @param costmap: The costmap for a given raster
     * @param startXy: The start position (no orientation)
     * @param goalXy: The goal position (no orientation)
     */

    function AstarSearch(costmap, startXy1, goalXy1) {
      this.costmap = costmap;
      this.startXy = startXy1;
      this.goalXy = goalXy1;
      AstarSearch.__super__.constructor.call(this, 10.0, 10.0);
    }

    AstarSearch.prototype.run = function(startXy, goalXy) {
      var counter, foundMatch, goal, i, j, lastNode, openLst, q, ref, start, successorLst;
      if (startXy.x < 0 || startXy.x >= this.costmap.cols || startXy.y < 0 || startXy.y > this.costmap.rows || goalXy.x < 0 || goalXy.x >= this.costmap.rows || goalXy.y < 0 || goalXy.y > this.costmap.cols) {
        console.log("ERROR: start or goal pos exeeds image bounds -- bye!");
        console.log("map (x, y): (" + this.costmap.rows + ", " + this.costmap.cols + ")");
        console.log("(" + startXy.x + ", " + startXy.y + ") ==> (" + goalXy.x + ", " + goalXy.y + ")");
        return;
      }
      openLst = [];
      start = new SearchNode.SearchNode(startXy.x, startXy.y, 0, 0, null);
      goal = new SearchNode.SearchNode(goalXy.x, goalXy.y, 0, 0, null);
      openLst.push(start);
      this.closedmap = new Image.Image('/home/james/CsProjects/CxxProjects/Agdl/AgdlCv/res/maze_inverted.png');
      this.closedmap.zeros();
      this.openmap = new Image.Image('/home/james/CsProjects/CxxProjects/Agdl/AgdlCv/res/maze_inverted.png');
      this.openmap.zeros();
      this.openmap.setAt2(start.x, start.y, start.f + 1.0, start.f + 1.0, start.f + 1.0);
      counter = 0;
      while (openLst.length > 0 && counter++ < 400) {
        q = new SearchNode.SearchNode();
        q = openLst.pop();
        this.openmap.setAt2(q.x, q.y, 0.0, 0.0, 0.0);
        console.log("(" + q.x + ", " + q.y + "): q.pixSum: " + q.pixSum + " q.pix: " + q.pix);
        successorLst = this.getSuccessors(q);
        for (i = j = 0, ref = successorLst.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          successorLst[i].g = q.g + this.calcLinearDistance(successorLst[i], q);
          successorLst[i].h = this.calcManhattenDistance(successorLst[i], goal);
          successorLst[i].f = successorLst[i].g + successorLst[i].h + successorLst[i].pixSum;
          if (successorLst[i].x === goal.x && successorLst[i].y === goal.y) {
            lastNode = successorLst[i].clone();
            if (this.useDebugMode) {
              console.log('Found goal -- Bye!');
              console.log(toString());
            }
            this.updateMask(lastNode);
            openLst = [];
            return;
          }
          foundMatch = false;
          if (this.openmap.getAt(successorLst[i].x, successorLst[i].y).r <= successorLst[i].f && this.openmap.getAt(successorLst[i].x, successorLst[i].y).r > 0.0) {
            foundMatch = true;
          }
          if (foundMatch === false) {
            if (this.closedmap.getAt(successorLst[i].x, successorLst[i].y).r <= successorLst[i].f && this.closedmap.getAt(successorLst[i].x, successorLst[i].y).r > 0) {
              foundMatch = true;
            }
          }
          if (foundMatch !== true) {
            openLst.push(successorLst[i]);
            if (successorLst[i].f > 0.0) {
              this.openmap.setAt2(successorLst[i].x, successorLst[i].y, successorLst[i].f, successorLst[i].f, successorLst[i].f);
            } else {
              this.openmap.setAt2(successorLst[i].x, successorLst[i].y, 1, 1, 1);
            }
          }
        }
        if (q.f > 0.0) {
          this.closedmap.setAt2(q.x, q.y, q.f, q.f, q.f);
        } else {
          this.closedmap.setAt2(q.x, q.y, 1.0, 1.0, 1.0);
        }
        successorLst = [];
      }

      /*
      fs = require('fs')
      obj = JSON.parse(fs.readFileSync('./path.json', 'utf8'))
      #console.log(obj)
      for idx, val of obj.path
          console.log val.y + ", " + val.x
          @costmap.setAt2(val.y, val.x, 100, 0, 100)
       */
      this.costmap.saveAsync('AAAcostmap.png');
      this.openmap.saveAsync('AAAopenmap.png');
      return this.closedmap.saveAsync('AAAclosedmap.png');
    };

    AstarSearch.prototype.getMask = function() {
      return this.smask;
    };

    AstarSearch.prototype.displayImage = function(windowName, image, useWaitKey, waitKey, x, y) {};

    AstarSearch.prototype.toString = function() {
      var str;
      str = '--------AstarSearch--------';
      str.append('\nnodes:=' + lastNode.childCount);
      str.append('\npixel cost:=' + lastNode.pixSum);
      str.append('\nnorth:=' + lastNode.twist.nCout);
      str.append('\nsouth:=' + lastNode.twist.sCount);
      str.append('\neast:=' + lastNode.twist.eCount);
      str.append('\nwest:=' + lastNode.twist.wCount);
      str.append('\nnorth-east:=' + lastNode.twist.neCount);
      str.append('\nnorth-west:=' + lastNode.twist.nwCount);
      str.append('\nsouth-east:=' + lastNode.twist.seCount);
      str.append('\nsouth-west:=' + lastNode.twist.swCount);
      str.append('\n---------------------------\\n');
      return str;
    };

    AstarSearch.prototype.getSuccessors = function(node) {
      var successors;
      successors = [];
      successors.push(this.generateNode(node.x + 1, node.y - 1, 3, 3, node));
      if (node.x > 5 && node.x < (this.costmap.cols - 5) && node.y > 5 && node.y < (this.costmap.rows - 5)) {
        successors.push(this.generateNode(node.x + 1, node.y - 1, 3, 3, node));
        successors.push(this.generateNode(node.x - 1, node.y + 1, 4, 4, node));
        successors.push(this.generateNode(node.x + 1, node.y + 1, 2, 2, node));
        successors.push(this.generateNode(node.x - 1, node.y - 1, 1, 1, node));
      }
      return successors;
    };

    AstarSearch.prototype.generateNode = function(x, y, direction, channel, parent) {
      var node;
      node = new SearchNode.SearchNode(x, y, direction, channel, parent);
      node.pix = this.costmap.getAt(x, y).r / 10;
      if (parent === null) {
        node.pixSum = node.pix;
      } else if (parent.pixSum + node.pix < 256 - 1) {
        node.pixSum = parent.pixSum + node.pix;
      } else {
        node.pixSum = 256 - 10;
      }
      return node;
    };

    AstarSearch.prototype.display = function(openLst, closedLst, start, goal) {};

    AstarSearch.prototype.display = function(lastNode, openLst, closedLst, start, goal) {};

    AstarSearch.prototype.updateMask = function(lastNode) {};

    return AstarSearch;

  })(SearchAbc.SearchAbc);

  if (typeof module !== "undefined" && module.exports) {
    exports.AstarSearch = AstarSearch;
  } else {
    window.AstarSearch = AstarSearch;
  }

}).call(this);

//# sourceMappingURL=AstarSearch.js.map
